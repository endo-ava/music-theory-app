# フロントエンド設計規約

## 1\. コンポーネント設計 (Next.js)

パフォーマンスと保守性の観点から、サーバーコンポーネントとクライアントコンポーネントを以下の方針で明確に使い分ける。

### 1.1. サーバーコンポーネントをデフォルトとする原則

コンポーネントは、まずサーバーコンポーネントとして実装することを基本とする。これにより、クライアントに送信されるJavaScript量を最小化し、初期表示性能を最大化する。データフェッチやファイルシステムアクセスなど、サーバーサイドで完結すべき処理はサーバーコンポーネントに閉じる。

### 1.2. クライアントコンポーネントは「インタラクションの末端」に限定

`useState`, `useEffect`といったフックや、`onClick`などのイベントリスナーが必要な、インタラクティブ性が求められる部分のみをクライアントコンポーネント (`'use client'`)として切り出す。重要なのは、ページ全体のような大きな単位ではなく、インタラクティブな機能を担当する最小単位のコンポーネントをクライアントコンポーネントとすること（**"Push Client Components to the leaves"** の思想）。

### 1.3. データの受け渡しは "Server to Client"

サーバーコンポーネントでデータを取得し、それをプロパティとしてクライアントコンポーネントに渡す。この単方向のデータフローにより、関心の分離を徹底する。

### 1.4. 状態管理（State Management）の方針

状態管理の複雑さを避けるため、以下の優先順位で適切な手法を選択する。

1.  **データフェッチとURL State:** サーバーコンポーネントでのデータ取得を基本とし、フィルタリングやソートなどの状態はURLパラメータで管理することを推奨する。
2.  **ローカルState:** コンポーネント個別の状態は `useState` や `useReducer` で管理する。
3.  **グローバルState:** 複数のコンポーネント間で共有する必要がある、真にグローバルな状態に限り、Zustandなどの軽量なライブラリの導入を検討する。

### 1.5. Server Actionsの活用

フォーム送信などのデータ更新処理は、Server Actionsを積極的に利用する。これにより、クライアントサイドのJavaScriptを介さずにサーバー上の関数を実行でき、クライアントコンポーネントをさらに削減できる。

## 2\. スタイリング

Tailwind CSS v4 を基本とし、デザイントークンの一元管理とユーティリティファーストの原則に従う。下記の3つのルールに集約する。基本的には`src/app/globals.css`を信頼できる唯一の情報源（Single Source of Truth）とする。

### 2.1. デザインの基本部品（色、フォント、間隔など）

- **場所**: `src/app/globals.css` の `@theme` ブロックの中。
- **書き方**: CSSの変数（カスタムプロパティ）として定義する。

### 2.2. 全体に適用する基本スタイル（body, h1など）

- **場所**: `src/app/globals.css` の `@layer base` ブロックの中。
- **書き方**: 上で定義した変数を `theme()` で呼び出して使う。

### 2.3. 各コンポーネントの個別スタイル

- **場所**: 各コンポーネントファイル（.tsx）の `className` の中。
- **書き方**: Tailwindのユーティリティクラスを直接書く。これにより、HTML構造からスタイルが予測可能になる。

## 3\. classNameによるスタイリング設計

基本原則: これらの規約は、コンポーネントの **再利用性** と **保守性** を最大化するための「原則」である。例外的な実装が必要な場合は、この原則に立ち返り、なぜ例外とするのかを意識すること。

コンポーネント配置時の`className`は、必ず以下を検討する：

1.  この配置は将来的に他の要素が追加されることを考慮しているか？
2.  レスポンシブ対応時に破綻しないか？
3.  `justify-*` や `items-*` ではなく、空間分割で解決できないか？

### 3.1. 責任分離の原則

**基本ルール**: レイアウト責任と描画責任を明確に分離せよ。

コンポーネントは、自身の「見た目」にのみ責任を持ち、配置される場所やサイズ（レイアウト）に関する情報を持つべきではない。

- **親コンポーネントの責任（外部制御）**:

  - サイズ指定（`w-`, `h-`）
  - 位置・配置（`m-`, `p-`, `justify-`, `items-`）
  - レスポンシブサイズ（`sm:`, `md:`, `lg:`等のサイズ変更）

- **子コンポーネントの責任（内部制御）**:

  - コンポーネントの基本的な見た目（`color`, `border`, `background`等）
  - 固定的な内部レイアウト構造（`flex`, `grid`等、毎回同じになるもの）
  - アクセシビリティ関連のスタイル

- ❌ **悪い例**: 子コンポーネントでマージンや幅を指定する。

- ✅ **良い例**: 親コンポーネントが`className`を通じて子のレイアウトを決定する。

### 3.2. className統一指針

- 全てのコンポーネントで **`twMerge` を使用**する。外部から渡された`className`とコンポーネント内部のデフォルトクラスを安全にマージするために必須。
- 条件に応じてクラスを動的に切り替える場合にのみ、`clsx` を併用する。

### 3.3. 再利用性の確保

- ❌ **悪い例**: 特定の用途に限定されるスタイル（例: `mt-10`）をコンポーネント内部に記述する。
- ✅ **良い例**: コンポーネントの基本的なスタイルのみを内部に保持し、配置に関するスタイルは外部から注入する。

### 3.4. 不要なdiv撲滅運動

単一要素を不必要に`div`で囲まない。

```jsx
// ❌ 悪い例
<div className="flex-shrink-0">
  <Title className="..." />
</div>

// ✅ 良い例
<Title className="... flex-shrink-0" />
```

**例外**: 以下の場合などは`div`で囲むことを許可する。

- 複数の子要素をグループ化する場合
- 子コンポーネントの内部実装とスタイルが競合する場合
- `flex`や`grid`のコンテナとして必要な場合
