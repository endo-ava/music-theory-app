# 開発原則・思想

音楽理論アプリ開発における基本的な設計思想と開発原則をまとめたガイドライン。

## 核となる開発思想

### 🎯 YAGNI（You Ain't Gonna Need It）

「今必要でない機能は実装しない」

**基本原則**:

- 現在の要件に集中し、将来必要になるかもしれない機能は実装しない
- 必要になった時点で追加する
- 推測に基づく実装は避ける

**音楽理論アプリでの具体例**:

- Scaleクラスでは、現在必要な`getNotes()`や`getDegree()`のみ実装
- MIDI変換やMusicXMLエクスポートは「いつか使うかも」では実装しない
- ユーザーからの実際の要望があってから機能を追加

### 🔧 KISS（Keep It Simple, Stupid）

「シンプルに保つ」

**基本原則**:

- 複雑さを避け、理解しやすいコードを書く
- 最も単純な解決策を選ぶ
- 不必要な抽象化は行わない

**音楽理論アプリでの具体例**:

- コード生成では、複雑なファクトリーパターンよりシンプルな静的メソッドを選択
- 音楽理論の実装では、理解しやすい直接的なメソッド名を使用
- 過度な抽象化より、明確で理解しやすいコードを優先

## SOLID原則

### 🎯 S - Single Responsibility Principle（単一責任原則）

「1つのクラスは1つの責任のみを持つ」

**適用例**:

- コード進行の管理では、保存・再生・バリデーション・UI表示を別々のクラスに分離
- ChordProgressionクラスはデータと基本操作のみ担当
- ProgressionValidatorはバリデーションのみ、ProgressionPlayerは再生のみ担当

### 🔓 O - Open/Closed Principle（開放/閉鎖原則）

「拡張に対して開かれ、修正に対して閉じている」

**適用例**:

- 新しい楽器を追加する際に、既存のInstrumentクラスを変更せずに拡張可能
- スケールタイプを新たに追加する場合も、基底クラスを修正せずに実現
- インターフェースや抽象クラスを使って拡張性を確保

### 🔄 L - Liskov Substitution Principle（リスコフ置換原則）

「サブクラスは基底クラスと置換可能である」

**適用例**:

- MajorScaleやMinorScaleなどのサブクラスは、Scaleの基本機能を同じように提供
- どのスケールタイプでも、getNotes()メソッドは期待される結果を返す
- 基底クラスが期待する動作を破らない

### 🔌 I - Interface Segregation Principle（インターフェース分離原則）

「クライアントは必要のないメソッドに依存すべきでない」

**適用例**:

- 音楽要素を機能ごとに分離：Playable（再生機能）、Persistable（保存機能）、Transposable（移調機能）
- クライアントは必要な機能のみを依存
- 大きなインターフェースを細かく分割して使いやすく

### 🔄 D - Dependency Inversion Principle（依存性逆転原則）

「高レベルモジュールは低レベルモジュールに依存すべきでない」

**適用例**:

- ChordPlayerは具体的な音声プレーヤーではなく、AudioPlayerインターフェースに依存
- 具体的な実装を変更しても、ChordPlayerのコードは変更不要
- テスト時にモックを簡単に作成可能

## その他の重要な原則

### 📝 DRY（Don't Repeat Yourself）

「同じコードを繰り返し書かない」

**適用指針**:

- 共通ロジックは関数やクラスに抽出
- 音楽理論の計算処理は再利用可能な形で実装
- 設定値やマジックナンバーは定数として定義

### 🎨 関心の分離（Separation of Concerns）

「異なる機能は異なる場所に配置する」

**適用指針**:

- UIロジックとビジネスロジックを分離
- ドメインロジック、アプリケーションロジック、プレゼンテーションロジックを明確に分ける
- 音楽理論の処理とUI表示の処理を独立させる

### ⚖️ POLA（Principle of Least Astonishment）

「最小驚きの原則」

**適用指針**:

- メソッド名から動作が予想できるように命名
- 一般的な音楽用語を使用（isDissonant、isConsonantなど）
- 直感的で予期される動作を実装

### 🛡️ Fail Fast

「問題を早期に発見し、すぐに失敗する」

**適用指針**:

- 不正な入力値は早期に検証してエラーを投出
- 音楽理論的に正しくない値は即座にエラー
- 問題を隠すのではなく、明確に失敗させる

## 実装時の判断基準

### 🤔 設計判断のチェックリスト

1. **シンプルさ**: この実装は理解しやすいか？
2. **テスタビリティ**: テストしやすい構造になっているか？
3. **拡張性**: 新しい要件に対応しやすいか？
4. **保守性**: 将来修正しやすいか？
5. **音楽理論の正確性**: 音楽的に正しいか？

### ⚠️ 原則の過度な適用を避ける

- 原則は手段であり目的ではない
- 現在のプロジェクトサイズと要件に適した抽象化レベルを選ぶ
- 過度な設計は逆に保守性を下げる可能性がある

## 音楽理論アプリ特有の考慮点

### 🎼 音楽理論の正確性を最優先

- 理論的に正しい実装を心がける
- 音楽的に意味のある抽象化を選ぶ
- 音楽家にとって自然な概念とコードの対応を保つ

### 🎹 直感的なAPI設計

- 音楽知識のあるユーザーにとって理解しやすいメソッド名
- 音楽理論の概念と一致する設計
- 複雑な音楽理論をシンプルなAPIで表現

### 🎵 パフォーマンスとの両立

- リアルタイム音声処理を考慮した設計
- 重い処理は適切に分離
- ユーザー体験を損なわない最適化

## まとめ

これらの原則は**指針**であり、**絶対的なルール**ではありません。プロジェクトの文脈、チームの状況、要件の複雑さを考慮して適切に適用してください。

**最も重要なのは**:

- 読みやすく保守しやすいコード
- 音楽理論の正確な実装
- チーム全体での一貫した開発スタイル

**判断に迷った時は**:

1. 音楽理論的に正しいか
2. 他の開発者が理解しやすいか
3. 将来の変更に対応しやすいか

この3点を基準に設計判断を行ってください。
