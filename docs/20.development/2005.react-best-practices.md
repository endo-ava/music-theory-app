# React ベストプラクティス

> **目的**: React コンポーネントのコード品質を最大化するための実践ガイド
> **基盤**: React 19 公式ドキュメント + プロジェクト固有の規約

---

## 1. コンポーネント設計の原則

### 1.1 単一責任の原則 (Single Responsibility)

各コンポーネントは「1つの明確な責任」のみを持つべきです。コンポーネント名が「and」や「or」で説明される場合、行数が50行を超える場合、あるいは3つ以上のStateを管理している場合は、分割を検討してください。

### 1.2 Props vs State の使い分け

- **Props**: 親から渡される「設定値」。読み取り専用であり、関数の引数に相当します。
- **State**: コンポーネント内部で管理される「メモリ」。ユーザー入力や時間経過で変化するデータです。
- **注意**: Propsから受け取った値や、他の値から計算可能な値をStateに保存してはいけません（冗長性の排除）。

### 1.3 コンポーネントの純粋性 (Purity)

同じPropsを受け取ったら、常に同じJSXを返す「純粋関数」として実装してください。レンダリング中に外部変数を変更したり、APIを呼び出したりする副作用は厳禁です。副作用は `useEffect` やイベントハンドラ内で管理します。

---

## 2. Hooks の使用ガイドライン

### 2.1 useState: 状態管理の基本

- **最小限の原則**: 必要最小限の状態のみを定義し、計算可能な値はStateに含めないでください。
- **更新手法**: 現在の状態に依存する更新は「関数形式」を使用し、オブジェクトや配列は常に新しい参照を作成してイミュータブルに更新します。

### 2.2 useEffect: 副作用の管理

- **用途**: 外部システム（API、DOM、サブスクリプション）との同期にのみ使用します。
- **非推奨**: データフローの操作や、イベントハンドラで処理できるロジックに `useEffect` を使用しないでください。
- **依存配列**: 内部で使用するすべての変数を依存配列に含め、嘘をつかないようにします。

### 2.3 useMemo / useCallback: メモ化

- **原則**: パフォーマンス計測を行い、本当に必要な場合（計算コストが高い、参照の安定性が必要）にのみ使用します。
- **useCallback**: `React.memo` で最適化された子コンポーネントに関数を渡す場合に有効です。

---

## 3. TypeScript との組み合わせ

- **Propsの型定義**: `any` は使用せず、インターフェースで明示的に型を定義します。`children` を含む場合は `PropsWithChildren` を活用します。
- **イベントハンドラ**: `React.MouseEvent` や `React.ChangeEvent` など、Reactが提供する型定義を利用します。
- **カスタムフック**: 引数と戻り値の型を明示し、利用側が型推論の恩恵を受けられるようにします。

---

## 4. パフォーマンス最適化

- **React.memo**: 計算コストが高い、または再レンダリング頻度が高いコンポーネントに使用します。
- **リストレンダリング**: `key` には配列のインデックスやランダム値ではなく、データ固有の「一意で安定したID」を使用します。
- **遅延ロード**: 大きなコンポーネントやライブラリは `next/dynamic` 等を用いて動的にインポートし、初期ロード時間を短縮します。

---

## 5. アクセシビリティ (a11y)

- **セマンティックHTML**: `div` の乱用を避け、`button`, `article`, `nav` などの意味のあるタグを使用します。
- **ARIA属性**: 必要に応じて `aria-label` や `aria-expanded` などを付与し、スクリーンリーダー対応を行います。
- **キーボード操作**: インタラクティブな要素はキーボード（Tab, Enter, Space等）でも操作可能にします。

---

## 6. エラーハンドリング

- **Error Boundary**: コンポーネントツリーの一部でエラーが発生しても、アプリ全体がクラッシュしないよう、境界を設けてフォールバックUIを表示します。
- **非同期エラー**: `useEffect` 内などの非同期処理でのエラーは、`try-catch` で捕捉し、適切にStateへ反映してユーザーに通知します。

---

## 7. テストしやすいコンポーネント設計

- **ロジックの分離**: ビジネスロジックや状態管理はカスタムフックに切り出し、View（コンポーネント）と分離することで、ロジック単体のテストを容易にします。
- **依存性の注入**: 外部依存（分析ツールやAPIクライアントなど）はProps経由で受け取るように設計すると、テスト時にモックへの差し替えが容易になります。

---

## 8. プロジェクト固有のベストプラクティス

### 8.1 Server Component vs Client Component (Next.js)

- **デフォルト**: 基本的に Server Component として実装し、パフォーマンスとSEOを最適化します。
- **Client Component**: `useState`, `useEffect`, イベントリスナーが必要な場合のみ、`'use client'` ディレクティブを使用します。

### 8.2 DDD (ドメイン駆動設計) アプローチ

- UIコンポーネント内に複雑なビジネスロジック（音楽理論の計算など）を書かず、`domain` 層のモデルやサービスに委譲します。

### 8.3 Zustand ストア

- グローバル状態管理は、アプリ全体で共有が必要なデータ（ユーザー設定、オーディオ再生状態など）に限定し、局所的な状態は `useState` や `useReducer` で管理します。

---

## 9. チェックリスト

新しいコンポーネント作成時の確認事項：

- [ ] **単一責任**: 1つの役割に集中しているか？
- [ ] **純粋性**: 副作用を含まないか？
- [ ] **Props/State**: 適切な使い分けと型定義がされているか？
- [ ] **a11y**: セマンティックなマークアップか？
- [ ] **パフォーマンス**: 不要な再レンダリングや重い処理がないか？
- [ ] **エラー処理**: 予期せぬエラーでクラッシュしないか？
- [ ] **分離**: ロジックと表示、ドメイン知識が分離されているか？
