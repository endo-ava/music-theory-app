# 開発規約

## 1. はじめに

本ドキュメントは、この音楽理論学習アプリケーション開発プロジェクトにおける、コードの品質、一貫性、保守性を担保するための規約を定めるものである。
開発者（人間およびAI）は、本規約を遵守すること。

## 2. コーディング規約

### 2.1. フォーマットと静的解析

- **フォーマッタ**: コードフォーマットには `Prettier` を使用する。フォーマットルールはプロジェクトルートの `.prettierrc.json` に従うこと。
- **リンター**: 静的解析には `ESLint` を使用する。ルールは `eslint.config.mjs` に従うこと。
- **自動化**: コミット前に `husky` と `lint-staged` により、対象ファイルのフォーマットとリンティングが自動的に実行される。

### 2.2. 命名規則

- **コンポーネント**: `PascalCase`
- **変数, 関数, フック**: `camelCase`
- **型定義**: `PascalCase`
- **定数**: `UPPER_SNAKE_CASE`
- **ファイル名**: 原則として、コンポーネントは`PascalCase`、それ以外のフックやユーティリティ等は`camelCase`

### 2.3. 構文規約

- **変数宣言**: 再代入のない変数は `const` を使用する。再代入が避けられない場合のみ `let` を使用する。`var` は使用しない。
- **関数**: アロー関数 (`=>`) の使用を基本とする。
- **モジュール**: ES Modules (`import`/`export`) を使用する。CommonJS (`require`/`module.exports`) は使用しない。
- **TypeScript**:
  - `any` 型の安易な使用は原則として禁止する。型推論が困難な場合に限り、その理由をコメントで明記した上で使用を検討する。
  - コンポーネントの `Props` や関数の引数・返り値には、明確な型定義を付与すること。
  - 型定義は、コンポーネント固有のProps型は各コンポーネントファイルの冒頭に定義し、グローバルなものは `src/types` に配置する。

### 2.5. コメント

- **JSDoc**: 再利用される関数、コンポーネント、型定義には、その役割、引数 (`@param`)、返り値 (`@returns`) を示すJSDocを記述する。
- **意図の明記**: 意図の説明が必要と判断されるものに対しては、`なぜ (Why)` そのような実装になっているのか、という設計意図や背景をコメントとして残すことを推奨する。

## 3. フロントエンド設計規約

### 3.1. スタイリング

Tailwind CSS v4 を基本とし、デザイントークンの一元管理とユーティリティファーストの原則に従う。下記の3つのルールに集約する。基本的には`src/app/globals.css`を信頼できる唯一の情報源とする。

#### デザインの基本部品（色、フォント、間隔など）

- 場所: src/app/globals.css の @theme ブロックの中。
- 書き方: CSSの変数（カスタムプロパティ）として定義する。

#### 全体に適用する基本スタイル（body, h1など）

- 場所: src/app/globals.css の @layer base ブロックの中。
- 書き方: 上で定義した変数を theme() で呼び出して使う。

#### 各コンポーネントの個別スタイル

- 場所: 各コンポーネントファイル（.tsx）の className の中。
- 書き方: Tailwindのユーティリティクラスを直接書く。これでHTMLを見ればスタイルがわかる。
- 例： `items-center`, `justify-center` など

### 3.2. コンポーネント設計 (Next.js)

パフォーマンスと保守性の観点から、サーバーコンポーネントとクライアントコンポーネントを以下の方針で明確に使い分ける。

- サーバーコンポーネントをデフォルトとする原則

  - コンポーネントは、まずサーバーコンポーネントとして実装することを基本とする。これにより、クライアントに送信されるJavaScript量を最小化し、初期表示性能を最大化する。データフェッチやファイルシステムアクセスなど、サーバーサイドで完結すべき処理はサーバーコンポーネントに閉じる。

- クライアントコンポーネントは「インタラクションの末端」に限定
  - useState, useEffectといったフックや、onClickなどのイベントリスナーが必要な、インタラクティブ性が求められる部分のみをクライアントコンポーネント ('use client')として切り出す。重要なのは、ページ全体のような大きな単位ではなく、インタラクティブな機能を担当する最小単位のコンポーネントをクライアントコンポーネントとすること（"Push Client Components to the leaves" の思想）。

データの受け渡しは "Server to Client"
サーバーコンポーネントでデータを取得し、それをプロパティとしてクライアントコンポーネントに渡す。この単方向のデータフローにより、関心の分離を徹底する。

## 4. テスト戦略 (Testing Strategy)

本プロジェクトは、静的な情報表示アプリとは異なり、「インタラクティブな視覚表現」と「感覚的なフィードバック」そのものがプロダクトのコア価値となる。したがって、テスト戦略もその特性に合わせて最適化する。

### 4.1. 基本方針

**Storybookをテストの中心に据えた、ビジュアルファーストなテスト戦略**を採用する。

- **主軸 (80%)**: Storybookによるコンポーネントのインタラクションテストとビジュアルテスト。
- **補完 (20%)**: Vitestによるユーティリティ関数や複雑なロジックの単体テスト。

このアプローチにより、開発者は常に実際のブラウザ環境でコンポーネントの振る舞いと見た目を確認しながら、品質を確保することができる。

### 4.2. 各ツールの役割

#### 1. Storybook (主軸)

- **目的**: コンポーネントの主要なユースケースと視覚的な状態を網羅的にテストする。
- **担当範囲**:
  - **インタラクションテスト**: `play`関数を用い、ユーザーのクリックやホバーといった操作をシミュレートし、コンポーネントが期待通りに状態変化・描画されるかを検証する。
  - **ビジュアルリグレッションテスト**: Storybookのアドオン（例: Chromatic）と連携し、意図しないUIの見た目の変化（デグレード）を自動検知する。
  - **アクセシビリティテスト**: `a11y`アドオンを導入し、開発中にコンポーネント単位でのアクセシビリティ違反を継続的にチェックする。

#### 2. Vitest (補完)

- **目的**: Storybookではテストしにくい、あるいはテストする価値が低い「UIを介さないロジック」をピンポイントで検証する。
- **担当範囲**:
  - **ユーティリティ関数**: `src/components/CircleOfFifths/utils`に格納されているような、純粋な計算関数の単体テスト。
  - **複雑なロジック/エッジケース**: カスタムフック内部の複雑な条件分岐や、異常な引数が渡された場合の振る舞いなど、ストーリーとして表現する必要のないテストケース。
  - **状態管理(Store)**: Zustandストアのアクションが、正しく状態を更新するかのロジックテスト。

### 4.3. この戦略を採用する理由

- **視覚的正確性の担保**: アニメーションやSVG描画など、本アプリのコア価値である視覚的要素を、JSDOMではなく**実ブラウザ環境**でテストできる。
- **優れた開発体験 (DX)**: インタラクションテストの失敗をStorybookのUI上で視覚的に確認・デバッグできるため、問題解決の速度が向上する。
- **効率性**: 1つのストーリーファイルが「仕様書」「開発環境」「自動テスト」の3役を兼ねるため、開発とドキュメンテーション、テストを同時に進めることができる。

### 4.4. Vitestユニットテスト実装規約

**ファイル構成規約:**
- テストファイルは実装ファイルと同一ディレクトリ内の`test/`サブディレクトリに配置する
- テストファイル名は`[実装ファイル名].test.ts`の形式とする
- 例: `utils/validation.ts` → `utils/test/validation.test.ts`

**テストケース命名規約:**

1. **describe文**：
   - 形式: `'[モジュール名] [対象]'`
   - 例: `'validation utils'`, `'geometry utils'`
   - 関数別にネストする場合: `'[関数名]'`

2. **test文**：
   - 形式: `'[テストタイプ]: [期待する動作の日本語説明]'`
   - **正常ケース**: `'正常ケース: 有効な位置（0-11）でtrueを返す'`
   - **境界値ケース**: `'境界値ケース: 負の数でfalseを返す'`
   - **異常ケース**: `'異常ケース: 無効な位置でCircleOfFifthsErrorをスロー'`

**数値計算テスト規約:**
- 浮動小数点数の比較には`toBeCloseTo(expectedValue, precision)`を使用する
- 精度は計算の性質に応じて設定（通常は10桁: `toBeCloseTo(expected, 10)`）

**テストデータ規約:**
- 実際のアプリケーション定数（KEYS, CIRCLE_LAYOUT等）を活用する
- 音楽理論の正確性を検証するため、実際の五度圏データでテストする
- エッジケース用の仮想データと実データを明確に区別する

**カバレッジ目標:**
- ユーティリティ関数は100%のステートメント・ブランチカバレッジを目指す
- 全てのエラーパス（throw文）を網羅する
- 数学的な境界値（0, 負数, 上限値等）を必ずテストする

## 5. バージョン管理規約 (Git)

### 5.1. ブランチ戦略

- **基本フロー**: `GitHub Flow` を採用する。
- **`main` ブランチ**: 常にデプロイ可能な安定した状態を維持する。`main` ブランチへの直接のコミットは禁止とし、すべての変更は Pull Request を通じてマージする。
- **フィーチャーブランチ**: 新機能開発やバグ修正は `main` からブランチを作成して行う。

### 5.2. ブランチ命名規則

- **フォーマット**: `<type>/<short-description>` の形式とする。
- **例**:
  - `feat/add-sound-playback`
  - `fix/key-display-bug`
  - `refactor/optimize-svg-rendering`

### 5.3. コミットメッセージ

- **規約**: `Conventional Commits` の仕様に準拠する。
- **フォーマット**: `<type>: <subject>` メッセージは英語とする。
- **主な `<type>`**:
  - `feat`: 新機能の追加
  - `fix`: バグ修正
  - `docs`: ドキュメントの変更
  - `style`: コードフォーマットの修正など、機能に影響しない変更
  - `refactor`: リファクタリング
  - `test`: テストコードの追加・修正
  - `chore`: ビルドツールや設定ファイルの変更など

## 6. Pull Request (PR) 規約

- **PRの単位**: 1つのPRは、単一の関心事に対応させること。巨大なPRは避け、機能ごと、修正ごとに分割する。
- **PRテンプレート**: PR作成時は、必ずテンプレート (`.github/PULL_REQUEST_TEMPLATE.md`) の項目を埋めること。
- **セルフレビュー**: PRをレビュー依頼に出す前に、必ず作成者自身で変更内容を確認し、意図しない変更がないか、規約を遵守しているかを確認する。

## 7. ドキュメンテーション規約

- **README.md**: プロジェクトのルート、および主要なコンポーネントディレクトリには `README.md` を設置し、その概要、責務、使用方法などを記述する。
- **設計書**: 大規模な変更や機能追加を行う際は、`docs` ディレクトリ配下の関連設計書（要件定義、画面設計など）を更新する。
