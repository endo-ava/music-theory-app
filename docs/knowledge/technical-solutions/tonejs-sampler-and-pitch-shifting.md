# Tone.js Samplerとピッチシフトによる音域カバー技術

## 📚 目次

1. [Tone.js概要](#tonejs概要)
2. [Tone.Samplerの仕組み](#tonesampler の仕組み)
3. [ピッチシフト技術](#ピッチシフト技術)
4. [効率的な音域カバー手法](#効率的な音域カバー手法)
5. [実装例](#実装例)
6. [パフォーマンス考慮事項](#パフォーマンス考慮事項)

## Tone.js概要

### 🎵 Tone.jsとは

- **Web Audio API**の高レベルラッパー
- 音楽アプリケーション開発に特化したJavaScriptライブラリ
- リアルタイム音声合成・処理・再生に対応

### 主要機能

- **シンセサイザー**: 波形生成による音作り
- **サンプラー**: 録音された音源の再生・加工
- **エフェクト**: リバーブ、ディストーション等
- **シーケンサー**: タイミング制御・楽曲構成

### なぜSamplerを選択したか

| 手法             | 音質       | ファイルサイズ | リアルさ | 実装複雑度 |
| ---------------- | ---------- | -------------- | -------- | ---------- |
| **Tone.Synth**   | 合成音     | 小             | 低       | 低         |
| **Tone.Sampler** | リアル音源 | 中             | 高       | 中         |
| 全音階サンプル   | 最高       | 大             | 最高     | 高         |

**→ Samplerが音質・パフォーマンス・実装難易度のバランスが最適**

## Tone.Samplerの仕組み

### 基本概念

```typescript
const sampler = new Tone.Sampler({
  urls: {
    C4: 'piano-C4.mp3', // 基準音源
    'F#4': 'piano-Fs4.mp3', // 上位音源
  },
  baseUrl: 'https://example.com/samples/',
});
```

### 内部処理フロー

1. **音源選択**: 再生したい音程に最も近いサンプルを自動選択
2. **ピッチシフト**: 目標音程との差分を計算し、周波数調整
3. **音質最適化**: 変調量を最小化するサンプル選択

## ピッチシフト技術

### 🔬 音の高さの物理学

#### 周波数と音程の関係

```
音程 = 12 × log₂(f₁/f₀)
```

- **f₀**: 基準周波数（A4 = 440Hz）
- **f₁**: 対象周波数
- **結果**: 半音単位での音程差

#### 半音比率

```
1半音 = 2^(1/12) ≈ 1.059463
```

### デジタル音声処理

#### 1. 時間伸縮アルゴリズム

```javascript
// 概念的な処理
function pitchShift(audioBuffer, semitones) {
  const ratio = Math.pow(2, semitones / 12);
  return resampleAudio(audioBuffer, ratio);
}
```

#### 2. 品質劣化の傾向

```
ピッチシフト量 → 音質変化
±1半音: ほぼ無劣化
±3半音: 軽微な変化
±6半音: 明確な変化
±12半音: 著しい劣化
```

### 実際の周波数計算例

#### 基準: A4 = 440Hz

```
A3:  220.00Hz  (-12半音)
A#3: 233.08Hz  (-11半音)
B3:  246.94Hz  (-10半音)
C4:  261.63Hz  (-9半音)
...
A4:  440.00Hz  (基準)
...
A5:  880.00Hz  (+12半音)
```

## 効率的な音域カバー手法

### 🎹 戦略的サンプル配置

#### 当アプリケーションの実装

```typescript
urls: {
  C4: "C4.mp3",     // 261.63Hz (基準)
  "D#4": "Ds4.mp3", // 311.13Hz (+3半音)
  "F#4": "Fs4.mp3", // 369.99Hz (+6半音)
  A4: "A4.mp3",     // 440.00Hz (+9半音)
}
```

#### カバー範囲の計算

**C4サンプル (261.63Hz):**

- 下限: F#3 (185.00Hz) = -6半音
- 上限: F4 (349.23Hz) = +3半音
- **カバー範囲: F#3 ～ F4**

**D#4サンプル (311.13Hz):**

- 下限: A#3 (233.08Hz) = -3半音
- 上限: G#4 (415.30Hz) = +6半音
- **カバー範囲: A#3 ～ G#4**

**F#4サンプル (369.99Hz):**

- 下限: C#4 (277.18Hz) = -6半音
- 上限: B4 (493.88Hz) = +3半音
- **カバー範囲: C#4 ～ B4**

**A4サンプル (440.00Hz):**

- 下限: D#4 (311.13Hz) = -3半音
- 上限: D5 (587.33Hz) = +6半音
- **カバー範囲: D#4 ～ D5**

#### 統合カバー範囲

```
F#3 ---|C4|--- F4
      A#3 ---|D#4|--- G#4
            C#4 ---|F#4|--- B4
                  D#4 ---|A4|--- D5

結果: F#3 ～ D5 (約2オクターブ)
```

### 音質最適化戦略

#### 重複範囲での選択

```typescript
// 例: E4を再生する場合
// D#4サンプル: +1半音 (高品質) ← 選択される
// C4サンプル:  +5半音 (品質劣化)
```

**Tone.js は自動で最適なサンプルを選択！**

## 実装例

### 基本的な実装

```typescript
export class AudioEngine {
  private static sampler: Tone.Sampler | null = null;

  private static async ensureSampler(): Promise<void> {
    if (this.sampler) return;

    await Tone.start();

    this.sampler = new Tone.Sampler({
      urls: {
        C4: 'https://tonejs.github.io/audio/salamander/C4.mp3',
        'D#4': 'https://tonejs.github.io/audio/salamander/Ds4.mp3',
        'F#4': 'https://tonejs.github.io/audio/salamander/Fs4.mp3',
        A4: 'https://tonejs.github.io/audio/salamander/A4.mp3',
      },
      release: 1,
      baseUrl: '',
    }).toDestination();
  }

  static async playChord(chord: Chord): Promise<void> {
    await this.ensureSampler();

    const notes = chord.toneNotations;
    notes.forEach((note, i) => {
      setTimeout(() => {
        if (this.sampler) {
          this.sampler.triggerAttackRelease(note, 1.5);
        }
      }, i * 100);
    });
  }
}
```

### 五度圏での音域分析

```typescript
// 五度圏で使用される主要音程
const circleOfFifthsNotes = [
  'C4',
  'G4',
  'D4',
  'A4',
  'E4',
  'B4', // メジャー
  'F#4',
  'C#4',
  'G#4',
  'D#4',
  'A#4',
  'F4', // シャープ系
];

// すべて ±3半音以内の高品質範囲でカバー可能！
```

## パフォーマンス考慮事項

### 📊 ファイルサイズ比較

| アプローチ             | サンプル数 | 推定サイズ | 音質 | 実用性    |
| ---------------------- | ---------- | ---------- | ---- | --------- |
| **4サンプル (当実装)** | 4          | ~400KB     | 高   | ✅ 最適   |
| 1オクターブ            | 12         | ~1.2MB     | 最高 | ⚠️ 過剰   |
| フルピアノ             | 88         | ~8.8MB     | 完璧 | ❌ 重すぎ |

### ネットワーク最適化

```typescript
// 段階的ロード戦略の例
const essentialSamples = ['C4', 'F#4']; // 最優先
const extendedSamples = ['D#4', 'A4']; // 次優先

// 必要最小限から開始し、段階的に追加
```

### メモリ使用量

- **4サンプル**: ~400KB メモリ使用
- **Tone.js内部キャッシュ**: 効率的なメモリ管理
- **ガベージコレクション**: 自動的なクリーンアップ

## 🎯 まとめ

### この技術の利点

1. **音質**: リアルなピアノ音源
2. **効率性**: 最小限のファイル数で最大のカバー範囲
3. **パフォーマンス**: 軽量・高速ロード
4. **実装簡易性**: Tone.jsが複雑な処理を自動化

### 適用範囲

- **楽器アプリ**: ピアノ、ギター等の鍵盤楽器
- **音楽教育**: 音感訓練、楽理学習
- **ゲーム**: 音楽ゲーム、BGM生成
- **インタラクティブアート**: リアルタイム音響表現

### さらなる拡張の可能性

- **ベロシティレイヤー**: 強弱による音色変化
- **マルチサンプル**: より細かい音程刻み
- **音響効果**: リバーブ、コーラス等の追加
- **他楽器対応**: バイオリン、ギター等のサンプル

**このピッチシフト技術により、少ないリソースで豊かな音楽表現が実現できます！** 🎶
